{"version":3,"file":"index.es.js","sources":["../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/path-parser/node_modules/tslib/tslib.es6.js","../node_modules/path-parser/node_modules/search-params/dist/search-params.esm.js","../node_modules/path-parser/dist/path-parser.esm.js","../node_modules/search-params/dist/search-params.esm.js","../src/routeNode/helpers.ts","../src/routeNode/matchChildren.ts","../src/routeNode/sortChildren.ts","../src/routeNode/RouteNode.ts"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var makeOptions = function makeOptions(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return {\n    arrayFormat: opts.arrayFormat || 'none',\n    booleanFormat: opts.booleanFormat || 'none',\n    nullFormat: opts.nullFormat || 'default'\n  };\n};\n\nvar encodeValue = function encodeValue(value) {\n  return encodeURIComponent(value);\n};\n\nvar decodeValue = function decodeValue(value) {\n  return decodeURIComponent(value);\n};\n\nvar encodeBoolean = function encodeBoolean(name, value, opts) {\n  if (opts.booleanFormat === 'empty-true' && value) {\n    return name;\n  }\n\n  var encodedValue;\n\n  if (opts.booleanFormat === 'unicode') {\n    encodedValue = value ? '✓' : '✗';\n  } else {\n    encodedValue = value.toString();\n  }\n\n  return name + \"=\" + encodedValue;\n};\n\nvar encodeNull = function encodeNull(name, opts) {\n  if (opts.nullFormat === 'hidden') {\n    return '';\n  }\n\n  if (opts.nullFormat === 'string') {\n    return name + \"=null\";\n  }\n\n  return name;\n};\n\nvar getNameEncoder = function getNameEncoder(opts) {\n  if (opts.arrayFormat === 'index') {\n    return function (name, index) {\n      return name + \"[\" + index + \"]\";\n    };\n  }\n\n  if (opts.arrayFormat === 'brackets') {\n    return function (name) {\n      return name + \"[]\";\n    };\n  }\n\n  return function (name) {\n    return name;\n  };\n};\n\nvar encodeArray = function encodeArray(name, arr, opts) {\n  var encodeName = getNameEncoder(opts);\n  return arr.map(function (val, index) {\n    return encodeName(name, index) + \"=\" + encodeValue(val);\n  }).join('&');\n};\nvar encode = function encode(name, value, opts) {\n  if (value === null) {\n    return encodeNull(name, opts);\n  }\n\n  if (typeof value === 'boolean') {\n    return encodeBoolean(name, value, opts);\n  }\n\n  if (Array.isArray(value)) {\n    return encodeArray(name, value, opts);\n  }\n\n  return name + \"=\" + encodeValue(value);\n};\nvar decode = function decode(value, opts) {\n  if (value === undefined) {\n    return opts.booleanFormat === 'empty-true' ? true : null;\n  }\n\n  if (opts.booleanFormat === 'string') {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n  }\n\n  if (opts.booleanFormat === 'unicode') {\n    if (decodeValue(value) === '✓') {\n      return true;\n    }\n\n    if (decodeValue(value) === '✗') {\n      return false;\n    }\n  }\n\n  if (opts.nullFormat === 'string') {\n    if (value === 'null') {\n      return null;\n    }\n  }\n\n  return decodeValue(value);\n};\n\nvar getSearch = function getSearch(path) {\n  var pos = path.indexOf('?');\n\n  if (pos === -1) {\n    return path;\n  }\n\n  return path.slice(pos + 1);\n};\nvar isSerialisable = function isSerialisable(val) {\n  return val !== undefined;\n};\nvar parseName = function parseName(name) {\n  var bracketPosition = name.indexOf('[');\n  var hasBrackets = bracketPosition !== -1;\n  return {\n    hasBrackets: hasBrackets,\n    name: hasBrackets ? name.slice(0, bracketPosition) : name\n  };\n};\n\n/**\r\n * Parse a querystring and return an object of parameters\r\n */\n\nvar parse = function parse(path, opts) {\n  var options = makeOptions(opts);\n  return getSearch(path).split('&').reduce(function (params, param) {\n    var _a = param.split('='),\n        rawName = _a[0],\n        value = _a[1];\n\n    var _b = parseName(rawName),\n        hasBrackets = _b.hasBrackets,\n        name = _b.name;\n\n    var currentValue = params[name];\n    var decodedValue = decode(value, options);\n\n    if (currentValue === undefined) {\n      params[name] = hasBrackets ? [decodedValue] : decodedValue;\n    } else {\n      params[name] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);\n    }\n\n    return params;\n  }, {});\n};\n/**\r\n * Build a querystring from an object of parameters\r\n */\n\nvar build = function build(params, opts) {\n  var options = makeOptions(opts);\n  return Object.keys(params).filter(function (paramName) {\n    return isSerialisable(params[paramName]);\n  }).map(function (paramName) {\n    return encode(paramName, params[paramName], options);\n  }).filter(Boolean).join('&');\n};\n/**\r\n * Remove a list of parameters from a querystring\r\n */\n\nvar omit = function omit(path, paramsToOmit, opts) {\n  var options = makeOptions(opts);\n  var searchPart = getSearch(path);\n\n  if (searchPart === '') {\n    return {\n      querystring: '',\n      removedParams: {}\n    };\n  }\n\n  var _a = path.split('&').reduce(function (_a, chunk) {\n    var left = _a[0],\n        right = _a[1];\n    var rawName = chunk.split('=')[0];\n    var name = parseName(rawName).name;\n    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];\n  }, [[], []]),\n      kept = _a[0],\n      removed = _a[1];\n\n  return {\n    querystring: kept.join('&'),\n    removedParams: parse(removed.join('&'), options)\n  };\n};\n/**\r\n * Remove a list of parameters from a querystring\r\n */\n\nvar keep = function keep(path, paramsToKeep, opts) {\n  var options = makeOptions(opts);\n  var searchPart = getSearch(path);\n\n  if (searchPart === '') {\n    return {\n      keptParams: {},\n      querystring: ''\n    };\n  }\n\n  var kept = path.split('&').reduce(function (acc, chunk) {\n    var rawName = chunk.split('=')[0];\n    var name = parseName(rawName).name;\n\n    if (paramsToKeep.includes(name)) {\n      acc.push(chunk);\n    }\n\n    return acc;\n  }, []);\n  return {\n    keptParams: parse(kept.join('&'), options),\n    querystring: kept.join('&')\n  };\n};\n\nexport { build, keep, omit, parse };\n//# sourceMappingURL=search-params.esm.js.map\n","import { __assign } from 'tslib';\nimport { parse, build } from 'search-params';\n\n/**\r\n * We encode using encodeURIComponent but we want to\r\n * preserver certain characters which are commonly used\r\n * (sub delimiters and ':')\r\n *\r\n * https://www.ietf.org/rfc/rfc3986.txt\r\n *\r\n * reserved    = gen-delims / sub-delims\r\n *\r\n * gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\r\n *\r\n * sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\r\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n */\nvar excludeSubDelimiters = /[^!$'()*+,;|:]/g;\nvar encodeURIComponentExcludingSubDelims = function encodeURIComponentExcludingSubDelims(segment) {\n  return segment.replace(excludeSubDelimiters, function (match) {\n    return encodeURIComponent(match);\n  });\n};\nvar encodingMethods = {\n  \"default\": encodeURIComponentExcludingSubDelims,\n  uri: encodeURI,\n  uriComponent: encodeURIComponent,\n  none: function none(val) {\n    return val;\n  },\n  legacy: encodeURI\n};\nvar decodingMethods = {\n  \"default\": decodeURIComponent,\n  uri: decodeURI,\n  uriComponent: decodeURIComponent,\n  none: function none(val) {\n    return val;\n  },\n  legacy: decodeURIComponent\n};\nvar encodeParam = function encodeParam(param, encoding, isSpatParam) {\n  var encoder = encodingMethods[encoding] || encodeURIComponentExcludingSubDelims;\n\n  if (isSpatParam) {\n    return String(param).split('/').map(encoder).join('/');\n  }\n\n  return encoder(String(param));\n};\nvar decodeParam = function decodeParam(param, encoding) {\n  return (decodingMethods[encoding] || decodeURIComponent)(param);\n};\n\nvar defaultOrConstrained = function defaultOrConstrained(match) {\n  return '(' + (match ? match.replace(/(^<|>$)/g, '') : \"[a-zA-Z0-9-_.~%':|=+\\\\*@$]+\") + ')';\n};\nvar rules = [{\n  name: 'url-parameter',\n  pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n  regex: function regex(match) {\n    return new RegExp(defaultOrConstrained(match[2]));\n  }\n}, {\n  name: 'url-parameter-splat',\n  pattern: /^\\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,\n  regex: /([^?]*)/\n}, {\n  name: 'url-parameter-matrix',\n  pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n  regex: function regex(match) {\n    return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));\n  }\n}, {\n  name: 'query-parameter',\n  pattern: /^(?:\\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/\n}, {\n  name: 'delimiter',\n  pattern: /^(\\/|\\?)/,\n  regex: function regex(match) {\n    return new RegExp('\\\\' + match[0]);\n  }\n}, {\n  name: 'sub-delimiter',\n  pattern: /^(!|&|-|_|\\.|;)/,\n  regex: function regex(match) {\n    return new RegExp(match[0]);\n  }\n}, {\n  name: 'fragment',\n  pattern: /^([0-9a-zA-Z]+)/,\n  regex: function regex(match) {\n    return new RegExp(match[0]);\n  }\n}];\n\nvar tokenise = function tokenise(str, tokens) {\n  if (tokens === void 0) {\n    tokens = [];\n  } // Look for a matching rule\n\n\n  var matched = rules.some(function (rule) {\n    var match = str.match(rule.pattern);\n\n    if (!match) {\n      return false;\n    }\n\n    tokens.push({\n      type: rule.name,\n      match: match[0],\n      val: match.slice(1, 2),\n      otherVal: match.slice(2),\n      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex\n    });\n\n    if (match[0].length < str.length) {\n      tokens = tokenise(str.substr(match[0].length), tokens);\n    }\n\n    return true;\n  }); // If no rules matched, throw an error (possible malformed path)\n\n  if (!matched) {\n    throw new Error(\"Could not parse path '\" + str + \"'\");\n  }\n\n  return tokens;\n};\n\nvar exists = function exists(val) {\n  return val !== undefined && val !== null;\n};\n\nvar optTrailingSlash = function optTrailingSlash(source, strictTrailingSlash) {\n  if (strictTrailingSlash) {\n    return source;\n  }\n\n  if (source === '\\\\/') {\n    return source;\n  }\n\n  return source.replace(/\\\\\\/$/, '') + '(?:\\\\/)?';\n};\n\nvar upToDelimiter = function upToDelimiter(source, delimiter) {\n  if (!delimiter) {\n    return source;\n  }\n\n  return /(\\/)$/.test(source) ? source : source + '(\\\\/|\\\\?|\\\\.|;|$)';\n};\n\nvar appendQueryParam = function appendQueryParam(params, param, val) {\n  if (val === void 0) {\n    val = '';\n  }\n\n  var existingVal = params[param];\n\n  if (existingVal === undefined) {\n    params[param] = val;\n  } else {\n    params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];\n  }\n\n  return params;\n};\n\nvar defaultOptions = {\n  urlParamsEncoding: 'default'\n};\n\nvar Path =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function Path(path, options) {\n    if (!path) {\n      throw new Error('Missing path in Path constructor');\n    }\n\n    this.path = path;\n    this.options = __assign(__assign({}, defaultOptions), options);\n    this.tokens = tokenise(path);\n    this.hasUrlParams = this.tokens.filter(function (t) {\n      return /^url-parameter/.test(t.type);\n    }).length > 0;\n    this.hasSpatParam = this.tokens.filter(function (t) {\n      return /splat$/.test(t.type);\n    }).length > 0;\n    this.hasMatrixParams = this.tokens.filter(function (t) {\n      return /matrix$/.test(t.type);\n    }).length > 0;\n    this.hasQueryParams = this.tokens.filter(function (t) {\n      return /^query-parameter/.test(t.type);\n    }).length > 0; // Extract named parameters from tokens\n\n    this.spatParams = this.getParams('url-parameter-splat');\n    this.urlParams = this.getParams(/^url-parameter/); // Query params\n\n    this.queryParams = this.getParams('query-parameter'); // All params\n\n    this.params = this.urlParams.concat(this.queryParams); // Check if hasQueryParams\n    // Regular expressions for url part only (full and partial match)\n\n    this.source = this.tokens.filter(function (t) {\n      return t.regex !== undefined;\n    }).map(function (t) {\n      return t.regex.source;\n    }).join('');\n  }\n\n  Path.createPath = function (path, options) {\n    return new Path(path, options);\n  };\n\n  Path.prototype.isQueryParam = function (name) {\n    return this.queryParams.indexOf(name) !== -1;\n  };\n\n  Path.prototype.isSpatParam = function (name) {\n    return this.spatParams.indexOf(name) !== -1;\n  };\n\n  Path.prototype.test = function (path, opts) {\n    var _this = this;\n\n    var options = __assign(__assign({\n      caseSensitive: false,\n      strictTrailingSlash: false\n    }, this.options), opts); // trailingSlash: falsy => non optional, truthy => optional\n\n\n    var source = optTrailingSlash(this.source, options.strictTrailingSlash); // Check if exact match\n\n    var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\\\?.*$|$)' : '$'), options.caseSensitive, options.urlParamsEncoding); // If no match, or no query params, no need to go further\n\n    if (!match || !this.hasQueryParams) {\n      return match;\n    } // Extract query params\n\n\n    var queryParams = parse(path, options.queryParams);\n    var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {\n      return !_this.isQueryParam(p);\n    });\n\n    if (unexpectedQueryParams.length === 0) {\n      // Extend url match\n      Object.keys(queryParams).forEach( // @ts-ignore\n      function (p) {\n        return match[p] = queryParams[p];\n      });\n      return match;\n    }\n\n    return null;\n  };\n\n  Path.prototype.partialTest = function (path, opts) {\n    var _this = this;\n\n    var options = __assign(__assign({\n      caseSensitive: false,\n      delimited: true\n    }, this.options), opts); // Check if partial match (start of given path matches regex)\n    // trailingSlash: falsy => non optional, truthy => optional\n\n\n    var source = upToDelimiter(this.source, options.delimited);\n    var match = this.urlTest(path, source, options.caseSensitive, options.urlParamsEncoding);\n\n    if (!match) {\n      return match;\n    }\n\n    if (!this.hasQueryParams) {\n      return match;\n    }\n\n    var queryParams = parse(path, options.queryParams);\n    Object.keys(queryParams).filter(function (p) {\n      return _this.isQueryParam(p);\n    }).forEach(function (p) {\n      return appendQueryParam(match, p, queryParams[p]);\n    });\n    return match;\n  };\n\n  Path.prototype.build = function (params, opts) {\n    var _this = this;\n\n    if (params === void 0) {\n      params = {};\n    }\n\n    var options = __assign(__assign({\n      ignoreConstraints: false,\n      ignoreSearch: false,\n      queryParams: {}\n    }, this.options), opts);\n\n    var encodedUrlParams = Object.keys(params).filter(function (p) {\n      return !_this.isQueryParam(p);\n    }).reduce(function (acc, key) {\n      if (!exists(params[key])) {\n        return acc;\n      }\n\n      var val = params[key];\n\n      var isSpatParam = _this.isSpatParam(key);\n\n      if (typeof val === 'boolean') {\n        acc[key] = val;\n      } else if (Array.isArray(val)) {\n        acc[key] = val.map(function (v) {\n          return encodeParam(v, options.urlParamsEncoding, isSpatParam);\n        });\n      } else {\n        acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam);\n      }\n\n      return acc;\n    }, {}); // Check all params are provided (not search parameters which are optional)\n\n    if (this.urlParams.some(function (p) {\n      return !exists(params[p]);\n    })) {\n      var missingParameters = this.urlParams.filter(function (p) {\n        return !exists(params[p]);\n      });\n      throw new Error(\"Cannot build path: '\" + this.path + \"' requires missing parameters { \" + missingParameters.join(', ') + ' }');\n    } // Check constraints\n\n\n    if (!options.ignoreConstraints) {\n      var constraintsPassed = this.tokens.filter(function (t) {\n        return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);\n      }).every(function (t) {\n        return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);\n      });\n\n      if (!constraintsPassed) {\n        throw new Error(\"Some parameters of '\" + this.path + \"' are of invalid format\");\n      }\n    }\n\n    var base = this.tokens.filter(function (t) {\n      return /^query-parameter/.test(t.type) === false;\n    }).map(function (t) {\n      if (t.type === 'url-parameter-matrix') {\n        return \";\" + t.val + \"=\" + encodedUrlParams[t.val[0]];\n      }\n\n      return /^url-parameter/.test(t.type) ? encodedUrlParams[t.val[0]] : t.match;\n    }).join('');\n\n    if (options.ignoreSearch) {\n      return base;\n    }\n\n    var searchParams = this.queryParams.filter(function (p) {\n      return Object.keys(params).indexOf(p) !== -1;\n    }).reduce(function (sparams, paramName) {\n      sparams[paramName] = params[paramName];\n      return sparams;\n    }, {});\n    var searchPart = build(searchParams, options.queryParams);\n    return searchPart ? base + '?' + searchPart : base;\n  };\n\n  Path.prototype.getParams = function (type) {\n    var predicate = type instanceof RegExp ? function (t) {\n      return type.test(t.type);\n    } : function (t) {\n      return t.type === type;\n    };\n    return this.tokens.filter(predicate).map(function (t) {\n      return t.val[0];\n    });\n  };\n\n  Path.prototype.urlTest = function (path, source, caseSensitive, urlParamsEncoding) {\n    var _this = this;\n\n    var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');\n    var match = path.match(regex);\n\n    if (!match) {\n      return null;\n    } else if (!this.urlParams.length) {\n      return {};\n    } // Reduce named params to key-value pairs\n\n\n    return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {\n      params[_this.urlParams[i]] = decodeParam(m, urlParamsEncoding);\n      return params;\n    }, {});\n  };\n\n  return Path;\n}();\n\nexport { Path };\n//# sourceMappingURL=path-parser.esm.js.map\n","var makeOptions = function makeOptions(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return {\n    arrayFormat: opts.arrayFormat || 'none',\n    booleanFormat: opts.booleanFormat || 'none',\n    nullFormat: opts.nullFormat || 'default'\n  };\n};\n\nvar encodeValue = function encodeValue(value) {\n  return encodeURIComponent(value);\n};\n\nvar decodeValue = function decodeValue(value) {\n  return decodeURIComponent(value.replace(/\\+/g, ' '));\n};\n\nvar encodeBoolean = function encodeBoolean(name, value, opts) {\n  if (opts.booleanFormat === 'empty-true' && value) {\n    return name;\n  }\n\n  var encodedValue;\n\n  if (opts.booleanFormat === 'unicode') {\n    encodedValue = value ? '✓' : '✗';\n  } else {\n    encodedValue = value.toString();\n  }\n\n  return name + \"=\" + encodedValue;\n};\n\nvar encodeNull = function encodeNull(name, opts) {\n  if (opts.nullFormat === 'hidden') {\n    return '';\n  }\n\n  if (opts.nullFormat === 'string') {\n    return name + \"=null\";\n  }\n\n  return name;\n};\n\nvar getNameEncoder = function getNameEncoder(opts) {\n  if (opts.arrayFormat === 'index') {\n    return function (name, index) {\n      return name + \"[\" + index + \"]\";\n    };\n  }\n\n  if (opts.arrayFormat === 'brackets') {\n    return function (name) {\n      return name + \"[]\";\n    };\n  }\n\n  return function (name) {\n    return name;\n  };\n};\n\nvar encodeArray = function encodeArray(name, arr, opts) {\n  var encodeName = getNameEncoder(opts);\n  return arr.map(function (val, index) {\n    return encodeName(name, index) + \"=\" + encodeValue(val);\n  }).join('&');\n};\nvar encode = function encode(name, value, opts) {\n  var encodedName = encodeValue(name);\n\n  if (value === null) {\n    return encodeNull(encodedName, opts);\n  }\n\n  if (typeof value === 'boolean') {\n    return encodeBoolean(encodedName, value, opts);\n  }\n\n  if (Array.isArray(value)) {\n    return encodeArray(encodedName, value, opts);\n  }\n\n  return encodedName + \"=\" + encodeValue(value);\n};\nvar decode = function decode(value, opts) {\n  if (value === undefined) {\n    return opts.booleanFormat === 'empty-true' ? true : null;\n  }\n\n  if (opts.booleanFormat === 'string') {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n  }\n\n  if (opts.nullFormat === 'string') {\n    if (value === 'null') {\n      return null;\n    }\n  }\n\n  var decodedValue = decodeValue(value);\n\n  if (opts.booleanFormat === 'unicode') {\n    if (decodedValue === '✓') {\n      return true;\n    }\n\n    if (decodedValue === '✗') {\n      return false;\n    }\n  }\n\n  return decodedValue;\n};\n\nvar getSearch = function getSearch(path) {\n  var pos = path.indexOf('?');\n\n  if (pos === -1) {\n    return path;\n  }\n\n  return path.slice(pos + 1);\n};\nvar isSerialisable = function isSerialisable(val) {\n  return val !== undefined;\n};\nvar parseName = function parseName(name) {\n  var bracketPosition = name.indexOf('[');\n  var hasBrackets = bracketPosition !== -1;\n  return {\n    hasBrackets: hasBrackets,\n    name: hasBrackets ? name.slice(0, bracketPosition) : name\n  };\n};\n\n/**\r\n * Parse a querystring and return an object of parameters\r\n */\n\nvar parse = function parse(path, opts) {\n  var options = makeOptions(opts);\n  return getSearch(path).split('&').reduce(function (params, param) {\n    var _a = param.split('='),\n        rawName = _a[0],\n        value = _a[1];\n\n    var _b = parseName(rawName),\n        hasBrackets = _b.hasBrackets,\n        name = _b.name;\n\n    var decodedName = decodeValue(name);\n    var currentValue = params[name];\n    var decodedValue = decode(value, options);\n\n    if (currentValue === undefined) {\n      params[decodedName] = hasBrackets ? [decodedValue] : decodedValue;\n    } else {\n      params[decodedName] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);\n    }\n\n    return params;\n  }, {});\n};\n/**\r\n * Build a querystring from an object of parameters\r\n */\n\nvar build = function build(params, opts) {\n  var options = makeOptions(opts);\n  return Object.keys(params).filter(function (paramName) {\n    return isSerialisable(params[paramName]);\n  }).map(function (paramName) {\n    return encode(paramName, params[paramName], options);\n  }).filter(Boolean).join('&');\n};\n/**\r\n * Remove a list of parameters from a querystring\r\n */\n\nvar omit = function omit(path, paramsToOmit, opts) {\n  var options = makeOptions(opts);\n  var searchPart = getSearch(path);\n\n  if (searchPart === '') {\n    return {\n      querystring: '',\n      removedParams: {}\n    };\n  }\n\n  var _a = path.split('&').reduce(function (_a, chunk) {\n    var left = _a[0],\n        right = _a[1];\n    var rawName = chunk.split('=')[0];\n    var name = parseName(rawName).name;\n    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];\n  }, [[], []]),\n      kept = _a[0],\n      removed = _a[1];\n\n  return {\n    querystring: kept.join('&'),\n    removedParams: parse(removed.join('&'), options)\n  };\n};\n/**\r\n * Remove a list of parameters from a querystring\r\n */\n\nvar keep = function keep(path, paramsToKeep, opts) {\n  var options = makeOptions(opts);\n  var searchPart = getSearch(path);\n\n  if (searchPart === '') {\n    return {\n      keptParams: {},\n      querystring: ''\n    };\n  }\n\n  var kept = path.split('&').reduce(function (acc, chunk) {\n    var rawName = chunk.split('=')[0];\n    var name = parseName(rawName).name;\n\n    if (paramsToKeep.includes(name)) {\n      acc.push(chunk);\n    }\n\n    return acc;\n  }, []);\n  return {\n    keptParams: parse(kept.join('&'), options),\n    querystring: kept.join('&')\n  };\n};\n\nexport { build, keep, omit, parse };\n//# sourceMappingURL=search-params.esm.js.map\n","import { build } from 'search-params';\nimport { BuildOptions, MatchResponse, RouteNode, RouteNodeState, RouteNodeStateMeta } from './RouteNode';\n\nexport const getMetaFromSegments = (segments: RouteNode[]): RouteNodeStateMeta => {\n    let accName = '';\n\n    return segments.reduce<RouteNodeStateMeta>((meta, segment) => {\n        const urlParams =\n            segment.parser?.urlParams.reduce<Record<string, any>>((params, p) => {\n                params[p] = 'url';\n                return params;\n            }, {}) ?? {};\n\n        const allParams =\n            segment.parser?.queryParams.reduce<Record<string, any>>((params, p) => {\n                params[p] = 'query';\n                return params;\n            }, urlParams) ?? {};\n\n        if (segment.name !== undefined) {\n            accName = accName ? accName + '.' + segment.name : segment.name;\n            meta[accName] = allParams;\n        }\n\n        return meta;\n    }, {});\n};\n\nexport const buildStateFromMatch = (match: MatchResponse): RouteNodeState | null => {\n    if (!match || !match.segments || !match.segments.length) {\n        return null;\n    }\n\n    const name = match.segments\n        .map((segment) => segment.name)\n        .filter((name) => name)\n        .join('.');\n\n    const params = match.params;\n\n    return {\n        name,\n        params,\n        meta: getMetaFromSegments(match.segments),\n    };\n};\n\nexport const buildPathFromSegments = (segments: RouteNode[], params: Record<string, any> = {}, options: BuildOptions = {}) => {\n    const { queryParamsMode = 'default', trailingSlashMode = 'default' } = options;\n    const searchParams: string[] = [];\n    const nonSearchParams: string[] = [];\n\n    for (const segment of segments) {\n        const { parser } = segment;\n\n        if (parser) {\n            searchParams.push(...parser.queryParams);\n            nonSearchParams.push(...parser.urlParams);\n            nonSearchParams.push(...parser.spatParams);\n        }\n    }\n\n    if (queryParamsMode === 'loose') {\n        const extraParams = Object.keys(params).reduce<string[]>(\n            (acc, p) => (searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc),\n            []\n        );\n\n        searchParams.push(...extraParams);\n    }\n\n    const searchParamsObject = searchParams.reduce<Record<string, any>>((acc, paramName) => {\n        if (Object.keys(params).indexOf(paramName) !== -1) {\n            acc[paramName] = params[paramName];\n        }\n\n        return acc;\n    }, {});\n\n    const searchPart = build(searchParamsObject, options.queryParams);\n\n    const path = segments\n        .reduce<string>((path, segment) => {\n            const segmentPath =\n                segment.parser?.build(params, {\n                    ignoreSearch: true,\n                    queryParams: options.queryParams,\n                    urlParamsEncoding: options.urlParamsEncoding,\n                }) ?? '';\n\n            return segment.absolute ? segmentPath : path + segmentPath;\n        }, '')\n        // remove repeated slashes\n        .replace(/\\/\\/{1,}/g, '/');\n\n    let finalPath = path;\n\n    if (trailingSlashMode === 'always') {\n        finalPath = /\\/$/.test(path) ? path : `${path}/`;\n    } else if (trailingSlashMode === 'never' && path !== '/') {\n        finalPath = /\\/$/.test(path) ? path.slice(0, -1) : path;\n    }\n\n    return finalPath + (searchPart ? '?' + searchPart : '');\n};\n\nexport const getPathFromSegments = (segments: RouteNode[]): string | null => (segments ? segments.map((segment) => segment.path).join('') : null);\n","import { TestMatch } from 'path-parser';\nimport { omit, parse } from 'search-params';\nimport { MatchOptions, MatchResponse, RouteNode } from './RouteNode';\n\nconst getPath = (path: string): string => path.split('?')[0];\n\nconst getSearch = (path: string): string => path.split('?')[1] || '';\n\nconst matchChildren = (\n    nodes: RouteNode[],\n    pathSegment: string,\n    currentMatch: MatchResponse,\n    options: MatchOptions = {},\n    consumedBefore?: string\n): MatchResponse | null => {\n    const { queryParamsMode = 'default', strictTrailingSlash = false, strongMatching = true, caseSensitive = false } = options;\n\n    const isRoot = nodes.length === 1 && nodes[0].name === '';\n    // for (child of node.children) {\n    for (const child of nodes) {\n        // Partially match path\n        let match: TestMatch | null = null;\n        let remainingPath;\n        let segment = pathSegment;\n\n        if (consumedBefore === '/' && child.path[0] === '/') {\n            // when we encounter repeating slashes we add the slash\n            // back to the URL to make it de facto pathless\n            segment = '/' + pathSegment;\n        }\n\n        if (!child.children.length) {\n            match = child.parser!.test(segment, {\n                caseSensitive,\n                strictTrailingSlash,\n                queryParams: options.queryParams,\n                urlParamsEncoding: options.urlParamsEncoding,\n            });\n        }\n\n        if (!match) {\n            match = child.parser!.partialTest(segment, {\n                delimited: strongMatching,\n                caseSensitive,\n                queryParams: options.queryParams,\n                urlParamsEncoding: options.urlParamsEncoding,\n            });\n        }\n\n        if (match) {\n            // Remove consumed segment from path\n            let consumedPath = child.parser!.build(match, {\n                ignoreSearch: true,\n                urlParamsEncoding: options.urlParamsEncoding,\n            });\n\n            if (!strictTrailingSlash && !child.children.length) {\n                consumedPath = consumedPath.replace(/\\/$/, '');\n            }\n\n            // Can't create a regexp from the path because it might contain a\n            // regexp character.\n            if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {\n                remainingPath = segment.slice(consumedPath.length);\n            } else {\n                remainingPath = segment;\n            }\n\n            if (!strictTrailingSlash && !child.children.length) {\n                remainingPath = remainingPath.replace(/^\\/\\?/, '?');\n            }\n\n            const { querystring } = omit(getSearch(segment.replace(consumedPath, '')), child.parser!.queryParams, options.queryParams);\n\n            remainingPath = getPath(remainingPath) + (querystring ? `?${querystring}` : '');\n\n            if (!strictTrailingSlash && !isRoot && remainingPath === '/' && !/\\/$/.test(consumedPath)) {\n                remainingPath = '';\n            }\n\n            currentMatch.segments.push(child);\n            Object.keys(match).forEach((param) => (currentMatch.params[param] = match![param]));\n\n            if (!isRoot && !remainingPath.length) {\n                // fully matched\n                return currentMatch;\n            }\n\n            if (!isRoot && queryParamsMode !== 'strict' && remainingPath.indexOf('?') === 0) {\n                // unmatched queryParams in non strict mode\n                const remainingQueryParams = parse(remainingPath.slice(1), options.queryParams) as any;\n\n                Object.keys(remainingQueryParams).forEach((name) => (currentMatch.params[name] = remainingQueryParams[name]));\n\n                return currentMatch;\n            }\n\n            // Continue matching on non absolute children\n            const children = child.getNonAbsoluteChildren();\n            // If no children to match against but unmatched path left\n            if (!children.length) {\n                return null;\n            }\n\n            // Else: remaining path and children\n            return matchChildren(children, remainingPath, currentMatch, options, consumedPath);\n        }\n    }\n\n    return null;\n};\n\nexport default matchChildren;\n","import { RouteNode } from './RouteNode';\n\nexport default function sortChildren(children: RouteNode[]) {\n    const originalChildren = children.slice(0);\n\n    return children.sort(sortPredicate(originalChildren));\n}\n\nconst sortPredicate =\n    (originalChildren: RouteNode[]) =>\n    (left: RouteNode, right: RouteNode): number => {\n        const leftPath = left.path\n            .replace(/<.*?>/g, '')\n            .split('?')[0]\n            .replace(/(.+)\\/$/, '$1');\n\n        const rightPath = right.path\n            .replace(/<.*?>/g, '')\n            .split('?')[0]\n            .replace(/(.+)\\/$/, '$1');\n\n        // '/' last\n        if (leftPath === '/') {\n            return 1;\n        }\n\n        if (rightPath === '/') {\n            return -1;\n        }\n\n        // Spat params last\n        if (left.parser?.hasSpatParam) {\n            return 1;\n        }\n\n        if (right.parser?.hasSpatParam) {\n            return -1;\n        }\n\n        // No spat, number of segments (less segments last)\n        const leftSegments = (leftPath.match(/\\//g) || []).length;\n        const rightSegments = (rightPath.match(/\\//g) || []).length;\n        if (leftSegments < rightSegments) {\n            return 1;\n        }\n\n        if (leftSegments > rightSegments) {\n            return -1;\n        }\n\n        // Same number of segments, number of URL params ascending\n        const leftParamsCount = left.parser?.urlParams.length ?? 0;\n        const rightParamsCount = right.parser?.urlParams.length ?? 0;\n        if (leftParamsCount < rightParamsCount) {\n            return -1;\n        }\n\n        if (leftParamsCount > rightParamsCount) {\n            return 1;\n        }\n\n        // Same number of segments and params, last segment length descending\n        const leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;\n        const rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;\n        if (leftParamLength < rightParamLength) {\n            return 1;\n        }\n\n        if (leftParamLength > rightParamLength) {\n            return -1;\n        }\n\n        // Same last segment length, preserve definition order. Note that we\n        // cannot just return 0, as sort is not guaranteed to be a stable sort.\n        return originalChildren.indexOf(left) - originalChildren.indexOf(right);\n    };\n","import { Path, URLParamsEncodingType } from 'path-parser';\nimport { IOptions as QueryParamsOptions } from 'search-params';\n\nimport { buildPathFromSegments, buildStateFromMatch, getMetaFromSegments, getPathFromSegments } from './helpers';\nimport matchChildren from './matchChildren';\nimport sortChildren from './sortChildren';\n\nexport interface RouteDefinition {\n    name: string;\n    path: string;\n    [key: string]: any;\n}\nexport type Route = RouteNode | RouteDefinition;\nexport type Callback = (...args: any[]) => void;\nexport type TrailingSlashMode = 'default' | 'never' | 'always';\nexport type QueryParamsMode = 'default' | 'strict' | 'loose';\n\nexport interface BuildOptions {\n    trailingSlashMode?: TrailingSlashMode;\n    queryParamsMode?: QueryParamsMode;\n    queryParams?: QueryParamsOptions;\n    urlParamsEncoding?: URLParamsEncodingType;\n}\n\nexport interface MatchOptions {\n    caseSensitive?: boolean;\n    trailingSlashMode?: TrailingSlashMode;\n    queryParamsMode?: QueryParamsMode;\n    queryParams?: QueryParamsOptions;\n    strictTrailingSlash?: boolean;\n    strongMatching?: boolean;\n    urlParamsEncoding?: URLParamsEncodingType;\n}\n\nexport type { QueryParamsOptions };\n\nexport interface MatchResponse {\n    segments: RouteNode[];\n    params: Record<string, any>;\n}\n\nexport interface RouteNodeStateMeta {\n    [routeName: string]: {\n        [routeParams: string]: 'query' | 'url';\n    };\n}\n\nexport interface RouteNodeState {\n    name: string;\n    params: Record<string, any>;\n    meta: RouteNodeStateMeta;\n}\n\nexport interface RouteNodeOptions {\n    finalSort?: boolean;\n    onAdd?: Callback;\n    parent?: RouteNode;\n    sort?: boolean;\n}\n\nexport class RouteNode {\n    public name: string;\n    public absolute: boolean;\n    public path: string;\n    public parser: Path | null;\n    public children: RouteNode[];\n    public parent?: RouteNode;\n\n    constructor(name: string = '', path: string = '', childRoutes: Route[] = [], options: RouteNodeOptions = {}) {\n        this.name = name;\n        this.absolute = /^~/.test(path);\n        this.path = this.absolute ? path.slice(1) : path;\n\n        this.parser = this.path ? new Path(this.path) : null;\n        this.children = [];\n        this.parent = options.parent;\n\n        this.checkParents();\n\n        this.add(childRoutes, options.onAdd, options.finalSort ? false : options.sort !== false);\n\n        if (options.finalSort) {\n            this.sortDescendants();\n        }\n\n        return this;\n    }\n\n    public getParentSegments(segments: RouteNode[] = []): RouteNode[] {\n        return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();\n    }\n\n    public setParent(parent: RouteNode) {\n        this.parent = parent;\n        this.checkParents();\n    }\n\n    public setPath(path: string = '') {\n        this.path = path;\n        this.parser = path ? new Path(path) : null;\n    }\n\n    public add(route: Route | Route[], cb?: Callback, sort: boolean = true): this {\n        if (route === undefined || route === null) {\n            return this;\n        }\n\n        if (route instanceof Array) {\n            route.forEach((r) => this.add(r, cb, sort));\n            return this;\n        }\n\n        if (!(route instanceof RouteNode) && !(route instanceof Object)) {\n            throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');\n        } else if (route instanceof RouteNode) {\n            route.setParent(this);\n            this.addRouteNode(route, sort);\n        } else {\n            if (!route.name || !route.path) {\n                throw new Error('RouteNode.add() expects routes to have a name and a path defined.');\n            }\n\n            const routeNode = new RouteNode(route.name, route.path, route.children, {\n                finalSort: false,\n                onAdd: cb,\n                parent: this,\n                sort,\n            });\n\n            const fullName = routeNode\n                .getParentSegments([routeNode])\n                .map((_) => _.name)\n                .join('.');\n\n            if (cb) {\n                cb({\n                    ...route,\n                    name: fullName,\n                });\n            }\n\n            this.addRouteNode(routeNode, sort);\n        }\n\n        return this;\n    }\n\n    public addNode(name: string, path: string) {\n        this.add(new RouteNode(name, path));\n        return this;\n    }\n\n    public getPath(routeName: string): string | null {\n        const segmentsByName = this.getSegmentsByName(routeName);\n\n        return segmentsByName ? getPathFromSegments(segmentsByName) : null;\n    }\n\n    public getNonAbsoluteChildren(): RouteNode[] {\n        return this.children.filter((child) => !child.absolute);\n    }\n\n    public sortChildren() {\n        if (this.children.length) {\n            sortChildren(this.children);\n        }\n    }\n\n    public sortDescendants() {\n        this.sortChildren();\n        this.children.forEach((child) => child.sortDescendants());\n    }\n\n    public buildPath(routeName: string, params: Record<string, any> = {}, options: BuildOptions = {}): string {\n        const segments = this.getSegmentsByName(routeName);\n\n        if (!segments) {\n            throw new Error(\"[route-node][buildPath] '{routeName}' is not defined\");\n        }\n\n        return buildPathFromSegments(segments, params, options);\n    }\n\n    public buildState(name: string, params: Record<string, any> = {}): RouteNodeState | null {\n        const segments = this.getSegmentsByName(name);\n\n        if (!segments || !segments.length) {\n            return null;\n        }\n\n        return {\n            name,\n            params,\n            meta: getMetaFromSegments(segments),\n        };\n    }\n\n    public matchPath(path: string, options: MatchOptions = {}): RouteNodeState | null {\n        if (path === '' && !options.strictTrailingSlash) {\n            path = '/';\n        }\n\n        const match = this.getSegmentsMatchingPath(path, options);\n\n        if (!match) {\n            return null;\n        }\n\n        const matchedSegments = match.segments;\n\n        if (matchedSegments[0].absolute) {\n            const firstSegmentParams = matchedSegments[0].getParentSegments();\n\n            matchedSegments.reverse();\n            matchedSegments.push(...firstSegmentParams);\n            matchedSegments.reverse();\n        }\n\n        const lastSegment = matchedSegments[matchedSegments.length - 1];\n        const lastSegmentSlashChild = lastSegment.findSlashChild();\n\n        if (lastSegmentSlashChild) {\n            matchedSegments.push(lastSegmentSlashChild);\n        }\n\n        return buildStateFromMatch(match);\n    }\n\n    private addRouteNode(route: RouteNode, sort: boolean = true): this {\n        const names = route.name.split('.');\n\n        if (names.length === 1) {\n            // Check duplicated routes\n            if (this.children.map((child) => child.name).indexOf(route.name) !== -1) {\n                throw new Error(`Alias \"${route.name}\" is already defined in route node`);\n            }\n\n            // Check duplicated paths\n            if (this.children.map((child) => child.path).indexOf(route.path) !== -1) {\n                throw new Error(`Path \"${route.path}\" is already defined in route node`);\n            }\n\n            this.children.push(route);\n\n            if (sort) {\n                this.sortChildren();\n            }\n        } else {\n            // Locate parent node\n            const segments = this.getSegmentsByName(names.slice(0, -1).join('.'));\n            if (segments) {\n                route.name = names[names.length - 1];\n                segments[segments.length - 1].add(route);\n            } else {\n                throw new Error(`Could not add route named '${route.name}', parent is missing.`);\n            }\n        }\n\n        return this;\n    }\n\n    private checkParents() {\n        if (this.absolute && this.hasParentsParams()) {\n            throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');\n        }\n    }\n\n    private hasParentsParams(): boolean {\n        if (this.parent && this.parent.parser) {\n            const parser = this.parent.parser;\n            const hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;\n\n            return hasParams || this.parent.hasParentsParams();\n        }\n\n        return false;\n    }\n\n    private findAbsoluteChildren(): RouteNode[] {\n        return this.children.reduce<RouteNode[]>(\n            (absoluteChildren, child) => absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren()),\n            []\n        );\n    }\n\n    private findSlashChild(): RouteNode | undefined {\n        const slashChildren = this.getNonAbsoluteChildren().filter((child) => child.parser && /^\\/(\\?|$)/.test(child.parser.path));\n\n        return slashChildren[0];\n    }\n\n    private getSegmentsByName(routeName: string): RouteNode[] | null {\n        const findSegmentByName = (name: string, routes: RouteNode[]) => {\n            const filteredRoutes = routes.filter((r) => r.name === name);\n            return filteredRoutes.length ? filteredRoutes[0] : undefined;\n        };\n\n        const segments: RouteNode[] = [];\n        let routes = this.parser ? [this] : this.children;\n        const names = (this.parser ? [''] : []).concat(routeName.split('.'));\n\n        const matched = names.every((name) => {\n            const segment = findSegmentByName(name, routes);\n            if (segment) {\n                routes = segment.children;\n                segments.push(segment);\n                return true;\n            }\n\n            return false;\n        });\n\n        return matched ? segments : null;\n    }\n\n    private getSegmentsMatchingPath(path: string, options: MatchOptions): MatchResponse | null {\n        const topLevelNodes = this.parser ? [this] : this.children;\n        const startingNodes = topLevelNodes.reduce<RouteNode[]>((nodes, node) => nodes.concat(node, node.findAbsoluteChildren()), []);\n\n        const currentMatch = {\n            segments: [],\n            params: {},\n        };\n\n        const finalMatch = matchChildren(startingNodes, path, currentMatch, options);\n\n        if (finalMatch && finalMatch.segments.length === 1 && finalMatch.segments[0].name === '') {\n            return null;\n        }\n\n        return finalMatch;\n    }\n}\n"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","makeOptions","opts","arrayFormat","booleanFormat","nullFormat","encodeValue","encodeURIComponent","decodeValue","decodeURIComponent","encodeBoolean","encodedValue","value","name","encodeNull","getNameEncoder","encodeArray","encodeName","encode","Array","decode","excludeSubDelimiters","encodeURIComponentExcludingSubDelims","encodingMethods","uri","uriComponent","none","val","legacy","encodeURI","decodingMethods","encodeParam","encoder","String","decodeParam","encodedName","decodedValue","_sortChildren"],"mappings":"AAAe,SAAS,QAAQ,GAAG;AACnC,EAAE,QAAQ,GAAG,MAAM,CAAC,MAAM,IAAI,UAAU,MAAM,EAAE;AAChD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC/C,MAAM,IAAI,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;AAChC;AACA,MAAM,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;AAC9B,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE;AAC/D,UAAU,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AACpC,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA,IAAI,OAAO,MAAM,CAAC;AAClB,GAAG,CAAC;AACJ;AACA,EAAE,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AACzC;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAgBO,IAAIA,OAAQ,GAAG,oBAAW;AAC7BA,EAAAA,OAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,SAASF,QAAT,CAAkBG,CAAlB,EAAqB;AAC7C,SAAK,IAAIC,CAAJ,EAAOC,CAAC,GAAG,CAAX,EAAcC,CAAC,GAAGC,SAAS,CAACC,MAAjC,EAAyCH,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;AACjDD,MAAAA,CAAC,GAAGG,SAAS,CAACF,CAAD,CAAb;;AACA,WAAK,IAAII,CAAT,IAAcL,CAAd;AAAiB,YAAIH,MAAM,CAACS,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAjE;AACH;;AACD,WAAON,CAAP;AACH,GAND;;AAOA,SAAOH,OAAQ,CAACa,KAAT,CAAe,IAAf,EAAqBN,SAArB,CAAP;AACH,CATM;;ACbA,IAAMO,aAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAA;oBAACC,GAAAA;AAAAA,IAAAA,IAAAA,GAAAA,EAAAA;;;SAAwC;AAClEC,IAAAA,WAAW,EAAED,IAAI,CAAJA,WAAAA,IADqD,MAAA;AAElEE,IAAAA,aAAa,EAAEF,IAAI,CAAJA,aAAAA,IAFmD,MAAA;AAGlEG,IAAAA,UAAU,EAAEH,IAAI,CAAJA,UAAAA,IAAmB;AAHmC;AAA7D,CAAA;;AAMP,IAAMI,aAAW,GAAG,SAAdA,WAAc,CAAA,KAAA,EAAA;SAAwBC,kBAAkB,CAAlBA,KAAkB;AAA9D,CAAA;;AAEA,IAAMC,aAAW,GAAG,SAAdA,WAAc,CAAA,KAAA,EAAA;SAA2BC,kBAAkB,CAAlBA,KAAkB;AAAjE,CAAA;;AAEA,IAAMC,eAAa,GAAG,SAAhBA,aAAgB,CAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA;MAKhBR,IAAI,CAAJA,aAAAA,KAAAA,YAAAA,IAAJ,OAAkD;WAChD;;;MAGF;;MAEIA,IAAI,CAAJA,aAAAA,KAAJ,WAAsC;AACpCS,IAAAA,YAAY,GAAGC,KAAK,GAAA,GAAA,GAApBD,GAAAA;AADF,SAEO;AACLA,IAAAA,YAAY,GAAGC,KAAK,CAApBD,QAAeC,EAAfD;;;SAGQE,IAAI,GAAJA,GAAAA,GAAV;AAjBF,CAAA;;AAoBA,IAAMC,YAAU,GAAG,SAAbA,UAAa,CAAA,IAAA,EAAA,IAAA,EAAA;MACbZ,IAAI,CAAJA,UAAAA,KAAJ,UAAkC;WAChC;;;MAGEA,IAAI,CAAJA,UAAAA,KAAJ,UAAkC;WACtBW,IAAI,GAAd;;;SAGF;AATF,CAAA;;AAcA,IAAME,gBAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAA;MACjBb,IAAI,CAAJA,WAAAA,KAAJ,SAAkC;WACzB,UAAA,IAAA,EAAA,KAAA,EAAA;aAA4CW,IAAI,GAAJA,GAAAA,GAAAA,KAAAA,GAAH;AAAhD;;;MAGEX,IAAI,CAAJA,WAAAA,KAAJ,YAAqC;WAC5B,UAAA,IAAA,EAAA;aAA6BW,IAAI,GAAP;AAAjC;;;SAGK,UAAA,IAAA,EAAA;WAA0BA;AAAjC;AATF,CAAA;;AAYO,IAAMG,aAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA;MAKnBC,UAAU,GAAGF,gBAAc,CAAjC,IAAiC;SAE1B,GAAG,CAAH,GAAA,CACA,UAAA,GAAA,EAAA,KAAA,EAAA;WAAmBE,UAAU,CAAA,IAAA,EAAVA,KAAU,CAAVA,GAAAA,GAAAA,GAA2BX,aAAW,CAAzC,GAAyC;AADzD,GAAA,EAAA,IAAA,CAAP,GAAO;AAPF,CAAA;;AAYA,IAAMY,QAAM,GAAG,SAATA,MAAS,CAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA;MAKhBN,KAAK,KAAT,MAAoB;WACXE,YAAU,CAAA,IAAA,EAAjB,IAAiB;;;MAGf,OAAA,KAAA,KAAJ,WAAgC;WACvBJ,eAAa,CAAA,IAAA,EAAA,KAAA,EAApB,IAAoB;;;MAGlBS,KAAK,CAALA,OAAAA,CAAJ,KAAIA,GAAsB;WACjBH,aAAW,CAAA,IAAA,EAAA,KAAA,EAAlB,IAAkB;;;SAGVH,IAAI,GAAJA,GAAAA,GAAQP,aAAW,CAA7B,KAA6B;AAjBxB,CAAA;;AAoBA,IAAMc,QAAM,GAAG,SAATA,MAAS,CAAA,KAAA,EAAA,IAAA,EAAA;MAIhBR,KAAK,KAAT,WAAyB;WAChBV,IAAI,CAAJA,aAAAA,KAAAA,YAAAA,GAAAA,IAAAA,GAAP;;;MAGEA,IAAI,CAAJA,aAAAA,KAAJ,UAAqC;QAC/BU,KAAK,KAAT,QAAsB;aACpB;;;QAEEA,KAAK,KAAT,SAAuB;aACrB;;;;MAIAV,IAAI,CAAJA,aAAAA,KAAJ,WAAsC;QAChCM,aAAW,CAAXA,KAAW,CAAXA,KAAJ,KAAgC;aAC9B;;;QAEEA,aAAW,CAAXA,KAAW,CAAXA,KAAJ,KAAgC;aAC9B;;;;MAIAN,IAAI,CAAJA,UAAAA,KAAJ,UAAkC;QAC5BU,KAAK,KAAT,QAAsB;aACpB;;;;SAIGJ,aAAW,CAAlB,KAAkB;AAhCb,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGP;;;;;;;;;;;;;;;AAeA,IAAMa,oBAAoB,GAA1B,iBAAA;;AASO,IAAMC,oCAAoC,GAAG,SAAvCA,oCAAuC,CAAA,OAAA,EAAA;SAClD,OAAO,CAAP,OAAA,CAAA,oBAAA,EAAsC,UAAA,KAAA,EAAA;WAASf,kBAAkB,CAAlBA,KAAkB;AAAjE,GAAA;AADK,CAAA;;AAGP,IAAMgB,eAAe,GAGjB;aAAA,oCAAA;AAEFC,EAAAA,GAAG,EAFD,SAAA;AAGFC,EAAAA,YAAY,EAHV,kBAAA;AAIFC,EAAAA,IAAI,EAAE,SAAA,IAAA,CAAA,GAAA,EAAA;WAAOC;AAJX,GAAA;AAKFC,EAAAA,MAAM,EAAEC;AALN,CAHJ;AAWA,IAAMC,eAAe,GAGjB;aAAA,kBAAA;AAEFN,EAAAA,GAAG,EAFD,SAAA;AAGFC,EAAAA,YAAY,EAHV,kBAAA;AAIFC,EAAAA,IAAI,EAAE,SAAA,IAAA,CAAA,GAAA,EAAA;WAAOC;AAJX,GAAA;AAKFC,EAAAA,MAAM,EAAEnB;AALN,CAHJ;;AAWO,IAAMsB,WAAW,GAAG,SAAdA,WAAc,CAAA,KAAA,EAAA,QAAA,EAAA,WAAA,EAAA;MAKnBC,OAAO,GACXT,eAAe,CAAfA,QAAe,CAAfA,IADF;;MAGA,aAAiB;WACRU,MAAM,CAANA,KAAM,CAANA,CAAAA,KAAAA,CAAAA,GAAAA,EAAAA,GAAAA,CAAAA,OAAAA,EAAAA,IAAAA,CAAP,GAAOA;;;SAMFD,OAAO,CAACC,MAAM,CAArB,KAAqB,CAAP;AAfT,CAAA;;AAkBA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAA,KAAA,EAAA,QAAA,EAAA;SAGd,CAACJ,eAAe,CAAfA,QAAe,CAAfA,IAAD,kBAAA,EAAA,KAAA;AAHN,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDA,IAAM7B,WAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAA;oBAACC,GAAAA;AAAAA,IAAAA,IAAAA,GAAAA,EAAAA;;;SAAwC;AAClEC,IAAAA,WAAW,EAAED,IAAI,CAAJA,WAAAA,IADqD,MAAA;AAElEE,IAAAA,aAAa,EAAEF,IAAI,CAAJA,aAAAA,IAFmD,MAAA;AAGlEG,IAAAA,UAAU,EAAEH,IAAI,CAAJA,UAAAA,IAAmB;AAHmC;AAA7D,CAAA;;AAMP,IAAMI,WAAW,GAAG,SAAdA,WAAc,CAAA,KAAA,EAAA;SAAwBC,kBAAkB,CAAlBA,KAAkB;AAA9D,CAAA;;AAEO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAA,KAAA,EAAA;SACzBC,kBAAkB,CAACG,KAAK,CAALA,OAAAA,CAAAA,KAAAA,EAAnBH,GAAmBG,CAAD;AADb,CAAA;;AAGP,IAAMF,aAAa,GAAG,SAAhBA,aAAgB,CAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA;MAKhBR,IAAI,CAAJA,aAAAA,KAAAA,YAAAA,IAAJ,OAAkD;WAChD;;;MAGF;;MAEIA,IAAI,CAAJA,aAAAA,KAAJ,WAAsC;AACpCS,IAAAA,YAAY,GAAGC,KAAK,GAAA,GAAA,GAApBD,GAAAA;AADF,SAEO;AACLA,IAAAA,YAAY,GAAGC,KAAK,CAApBD,QAAeC,EAAfD;;;SAGQE,IAAI,GAAJA,GAAAA,GAAV;AAjBF,CAAA;;AAoBA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAAA,IAAA,EAAA,IAAA,EAAA;MACbZ,IAAI,CAAJA,UAAAA,KAAJ,UAAkC;WAChC;;;MAGEA,IAAI,CAAJA,UAAAA,KAAJ,UAAkC;WACtBW,IAAI,GAAd;;;SAGF;AATF,CAAA;;AAcA,IAAME,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAA;MACjBb,IAAI,CAAJA,WAAAA,KAAJ,SAAkC;WACzB,UAAA,IAAA,EAAA,KAAA,EAAA;aAA4CW,IAAI,GAAJA,GAAAA,GAAAA,KAAAA,GAAH;AAAhD;;;MAGEX,IAAI,CAAJA,WAAAA,KAAJ,YAAqC;WAC5B,UAAA,IAAA,EAAA;aAA6BW,IAAI,GAAP;AAAjC;;;SAGK,UAAA,IAAA,EAAA;WAA0BA;AAAjC;AATF,CAAA;;AAYO,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA;MAKnBC,UAAU,GAAGF,cAAc,CAAjC,IAAiC;SAE1B,GAAG,CAAH,GAAA,CACA,UAAA,GAAA,EAAA,KAAA,EAAA;WAAmBE,UAAU,CAAA,IAAA,EAAVA,KAAU,CAAVA,GAAAA,GAAAA,GAA2BX,WAAW,CAAzC,GAAyC;AADzD,GAAA,EAAA,IAAA,CAAP,GAAO;AAPF,CAAA;;AAYA,IAAMY,MAAM,GAAG,SAATA,MAAS,CAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA;MAKdiB,WAAW,GAAG7B,WAAW,CAA/B,IAA+B;;MAE3BM,KAAK,KAAT,MAAoB;WACXE,UAAU,CAAA,WAAA,EAAjB,IAAiB;;;MAGf,OAAA,KAAA,KAAJ,WAAgC;WACvBJ,aAAa,CAAA,WAAA,EAAA,KAAA,EAApB,IAAoB;;;MAGlBS,KAAK,CAALA,OAAAA,CAAJ,KAAIA,GAAsB;WACjBH,WAAW,CAAA,WAAA,EAAA,KAAA,EAAlB,IAAkB;;;SAGVmB,WAAW,GAAXA,GAAAA,GAAe7B,WAAW,CAApC,KAAoC;AAnB/B,CAAA;;AAsBA,IAAMc,MAAM,GAAG,SAATA,MAAS,CAAA,KAAA,EAAA,IAAA,EAAA;MAIhBR,KAAK,KAAT,WAAyB;WAChBV,IAAI,CAAJA,aAAAA,KAAAA,YAAAA,GAAAA,IAAAA,GAAP;;;MAGEA,IAAI,CAAJA,aAAAA,KAAJ,UAAqC;QAC/BU,KAAK,KAAT,QAAsB;aACpB;;;QAEEA,KAAK,KAAT,SAAuB;aACrB;;;;MAIAV,IAAI,CAAJA,UAAAA,KAAJ,UAAkC;QAC5BU,KAAK,KAAT,QAAsB;aACpB;;;;MAIEwB,YAAY,GAAG5B,WAAW,CAAhC,KAAgC;;MAE5BN,IAAI,CAAJA,aAAAA,KAAJ,WAAsC;QAChCkC,YAAY,KAAhB,KAA0B;aACxB;;;QAEEA,YAAY,KAAhB,KAA0B;aACxB;;;;SAIJ;AAlCK,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGA,IAAM,mBAAmB,GAAG,SAAtB,mBAAsB,CAAC,QAAD,EAA8C;AAC7E,MAAI,OAAO,GAAG,EAAd;AAEA,SAAO,QAAQ,CAAC,MAAT,CAAoC,UAAC,IAAD,EAAO,OAAP,EAAkB;AAAA;;AACzD,QAAM,SAAS,+CACX,OAAO,CAAC,MADG,qBACX,gBAAgB,SAAhB,CAA0B,MAA1B,CAAsD,UAAC,MAAD,EAAS,CAAT,EAAc;AAChE,MAAA,MAAM,CAAC,CAAD,CAAN,GAAY,KAAZ;AACA,aAAO,MAAP;AACH,KAHD,EAGG,EAHH,CADW,oCAID,EAJd;AAMA,QAAM,SAAS,gDACX,OAAO,CAAC,MADG,qBACX,iBAAgB,WAAhB,CAA4B,MAA5B,CAAwD,UAAC,MAAD,EAAS,CAAT,EAAc;AAClE,MAAA,MAAM,CAAC,CAAD,CAAN,GAAY,OAAZ;AACA,aAAO,MAAP;AACH,KAHD,EAGG,SAHH,CADW,oCAIM,EAJrB;;AAMA,QAAI,OAAO,CAAC,IAAR,KAAiB,SAArB,EAAgC;AAC5B,MAAA,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,GAAV,GAAgB,OAAO,CAAC,IAA3B,GAAkC,OAAO,CAAC,IAA3D;AACA,MAAA,IAAI,CAAC,OAAD,CAAJ,GAAgB,SAAhB;AACH;;AAED,WAAO,IAAP;AACH,GAnBM,EAmBJ,EAnBI,CAAP;AAoBH,CAvBM;AAyBA,IAAM,mBAAmB,GAAG,SAAtB,mBAAsB,CAAC,KAAD,EAAgD;AAC/E,MAAI,CAAC,KAAD,IAAU,CAAC,KAAK,CAAC,QAAjB,IAA6B,CAAC,KAAK,CAAC,QAAN,CAAe,MAAjD,EAAyD;AACrD,WAAO,IAAP;AACH;;AAED,MAAM,IAAI,GAAG,KAAK,CAAC,QAAN,CACR,GADQ,CACJ,UAAC,OAAD;AAAA,WAAa,OAAO,CAAC,IAArB;AAAA,GADI,EAER,MAFQ,CAED,UAAC,IAAD;AAAA,WAAU,IAAV;AAAA,GAFC,EAGR,IAHQ,CAGH,GAHG,CAAb;AAKA,MAAM,MAAM,GAAG,KAAK,CAAC,MAArB;AAEA,SAAO;AACH,IAAA,IAAI,EAAJ,IADG;AAEH,IAAA,MAAM,EAAN,MAFG;AAGH,IAAA,IAAI,EAAE,mBAAmB,CAAC,KAAK,CAAC,QAAP;AAHtB,GAAP;AAKH,CAjBM;AAmBA,IAAM,qBAAqB,GAAG,SAAxB,qBAAwB,CAAC,QAAD,EAAwB,MAAxB,EAA0D,OAA1D,EAAwF;AAAA,MAAhE,MAAgE;AAAhE,IAAA,MAAgE,GAAlC,EAAkC;AAAA;;AAAA,MAA9B,OAA8B;AAA9B,IAAA,OAA8B,GAAN,EAAM;AAAA;;AACzH,iBAAuE,OAAvE;AAAA,uCAAQ,eAAR;AAAA,MAAQ,eAAR,sCAA0B,SAA1B;AAAA,uCAAqC,iBAArC;AAAA,MAAqC,iBAArC,sCAAyD,SAAzD;AACA,MAAM,YAAY,GAAa,EAA/B;AACA,MAAM,eAAe,GAAa,EAAlC;;AAEA,yDAAsB,QAAtB,wCAAgC;AAAA,QAArB,OAAqB;AAC5B,QAAQ,MAAR,GAAmB,OAAnB,CAAQ,MAAR;;AAEA,QAAI,MAAJ,EAAY;AACR,MAAA,YAAY,CAAC,IAAb,OAAA,YAAY,EAAS,MAAM,CAAC,WAAhB,CAAZ;AACA,MAAA,eAAe,CAAC,IAAhB,OAAA,eAAe,EAAS,MAAM,CAAC,SAAhB,CAAf;AACA,MAAA,eAAe,CAAC,IAAhB,OAAA,eAAe,EAAS,MAAM,CAAC,UAAhB,CAAf;AACH;AACJ;;AAED,MAAI,eAAe,KAAK,OAAxB,EAAiC;AAC7B,QAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,MAApB,CAChB,UAAC,GAAD,EAAM,CAAN;AAAA,aAAa,YAAY,CAAC,OAAb,CAAqB,CAArB,MAA4B,CAAC,CAA7B,IAAkC,eAAe,CAAC,OAAhB,CAAwB,CAAxB,MAA+B,CAAC,CAAlE,GAAsE,GAAG,CAAC,MAAJ,CAAW,CAAX,CAAtE,GAAsF,GAAnG;AAAA,KADgB,EAEhB,EAFgB,CAApB;AAKA,IAAA,YAAY,CAAC,IAAb,OAAA,YAAY,EAAS,WAAT,CAAZ;AACH;;AAED,MAAM,kBAAkB,GAAG,YAAY,CAAC,MAAb,CAAyC,UAAC,GAAD,EAAM,SAAN,EAAmB;AACnF,QAAI,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA4B,SAA5B,MAA2C,CAAC,CAAhD,EAAmD;AAC/C,MAAA,GAAG,CAAC,SAAD,CAAH,GAAiB,MAAM,CAAC,SAAD,CAAvB;AACH;;AAED,WAAO,GAAP;AACH,GAN0B,EAMxB,EANwB,CAA3B;AAQA,MAAM,UAAU,GAAG,KAAK,CAAC,kBAAD,EAAqB,OAAO,CAAC,WAA7B,CAAxB;AAEA,MAAM,IAAI,GAAG,QAAQ,CAChB,MADQ,CACO,UAAC,IAAD,EAAO,OAAP,EAAkB;AAAA;;AAC9B,QAAM,WAAW,gDACb,OAAO,CAAC,MADK,qBACb,iBAAgB,KAAhB,CAAsB,MAAtB,EAA8B;AAC1B,MAAA,YAAY,EAAE,IADY;AAE1B,MAAA,WAAW,EAAE,OAAO,CAAC,WAFK;AAG1B,MAAA,iBAAiB,EAAE,OAAO,CAAC;AAHD,KAA9B,CADa,oCAKP,EALV;AAOA,WAAO,OAAO,CAAC,QAAR,GAAmB,WAAnB,GAAiC,IAAI,GAAG,WAA/C;AACH,GAVQ,EAUN,EAVM;AAAA,GAYR,OAZQ,CAYA,WAZA,EAYa,GAZb,CAAb;AAcA,MAAI,SAAS,GAAG,IAAhB;;AAEA,MAAI,iBAAiB,KAAK,QAA1B,EAAoC;AAChC,IAAA,SAAS,GAAG,MAAM,IAAN,CAAW,IAAX,IAAmB,IAAnB,GAA6B,IAA7B,MAAZ;AACH,GAFD,MAEO,IAAI,iBAAiB,KAAK,OAAtB,IAAiC,IAAI,KAAK,GAA9C,EAAmD;AACtD,IAAA,SAAS,GAAG,MAAM,IAAN,CAAW,IAAX,IAAmB,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAnB,GAAuC,IAAnD;AACH;;AAED,SAAO,SAAS,IAAI,UAAU,GAAG,MAAM,UAAT,GAAsB,EAApC,CAAhB;AACH,CAzDM;AA2DA,IAAM,mBAAmB,GAAG,SAAtB,mBAAsB,CAAC,QAAD;AAAA,SAA2C,QAAQ,GAAG,QAAQ,CAAC,GAAT,CAAa,UAAC,OAAD;AAAA,WAAa,OAAO,CAAC,IAArB;AAAA,GAAb,EAAwC,IAAxC,CAA6C,EAA7C,CAAH,GAAsD,IAAzG;AAAA,CAA5B;;;;;;;;ACtGP,IAAM,OAAO,GAAG,SAAV,OAAU,CAAC,IAAD;AAAA,SAA0B,IAAI,CAAC,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAA1B;AAAA,CAAhB;;AAEA,IAAM,SAAS,GAAG,SAAZ,SAAY,CAAC,IAAD;AAAA,SAA0B,IAAI,CAAC,KAAL,CAAW,GAAX,EAAgB,CAAhB,KAAsB,EAAhD;AAAA,CAAlB;;AAEA,IAAM,aAAa,GAAG,SAAhB,aAAgB,CAClB,KADkB,EAElB,WAFkB,EAGlB,YAHkB,EAIlB,OAJkB,EAKlB,cALkB,EAMI;AAAA,MAFtB,OAEsB;AAFtB,IAAA,OAEsB,GAFE,EAEF;AAAA;;AACtB,iBAAmH,OAAnH;AAAA,uCAAQ,eAAR;AAAA,MAAQ,eAAR,sCAA0B,SAA1B;AAAA,uCAAqC,mBAArC;AAAA,MAAqC,mBAArC,sCAA2D,KAA3D;AAAA,uCAAkE,cAAlE;AAAA,MAAkE,cAAlE,sCAAmF,IAAnF;AAAA,uCAAyF,aAAzF;AAAA,MAAyF,aAAzF,sCAAyG,KAAzG;AAEA,MAAM,MAAM,GAAG,KAAK,CAAC,MAAN,KAAiB,CAAjB,IAAsB,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,KAAkB,EAAvD,CAHsB;;AAAA;AAAA,QAKX,KALW;AAMlB;AACA,QAAI,KAAK,GAAqB,IAA9B;AACA,QAAI,aAAa,SAAjB;AACA,QAAI,OAAO,GAAG,WAAd;;AAEA,QAAI,cAAc,KAAK,GAAnB,IAA0B,KAAK,CAAC,IAAN,CAAW,CAAX,MAAkB,GAAhD,EAAqD;AACjD;AACA;AACA,MAAA,OAAO,GAAG,MAAM,WAAhB;AACH;;AAED,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,MAApB,EAA4B;AACxB,MAAA,KAAK,GAAG,KAAK,CAAC,MAAN,CAAc,IAAd,CAAmB,OAAnB,EAA4B;AAChC,QAAA,aAAa,EAAb,aADgC;AAEhC,QAAA,mBAAmB,EAAnB,mBAFgC;AAGhC,QAAA,WAAW,EAAE,OAAO,CAAC,WAHW;AAIhC,QAAA,iBAAiB,EAAE,OAAO,CAAC;AAJK,OAA5B,CAAR;AAMH;;AAED,QAAI,CAAC,KAAL,EAAY;AACR,MAAA,KAAK,GAAG,KAAK,CAAC,MAAN,CAAc,WAAd,CAA0B,OAA1B,EAAmC;AACvC,QAAA,SAAS,EAAE,cAD4B;AAEvC,QAAA,aAAa,EAAb,aAFuC;AAGvC,QAAA,WAAW,EAAE,OAAO,CAAC,WAHkB;AAIvC,QAAA,iBAAiB,EAAE,OAAO,CAAC;AAJY,OAAnC,CAAR;AAMH;;AAED,QAAI,KAAJ,EAAW;AACP;AACA,UAAI,YAAY,GAAG,KAAK,CAAC,MAAN,CAAc,KAAd,CAAoB,KAApB,EAA2B;AAC1C,QAAA,YAAY,EAAE,IAD4B;AAE1C,QAAA,iBAAiB,EAAE,OAAO,CAAC;AAFe,OAA3B,CAAnB;;AAKA,UAAI,CAAC,mBAAD,IAAwB,CAAC,KAAK,CAAC,QAAN,CAAe,MAA5C,EAAoD;AAChD,QAAA,YAAY,GAAG,YAAY,CAAC,OAAb,CAAqB,KAArB,EAA4B,EAA5B,CAAf;AACH,OATM;AAYP;;;AACA,UAAI,OAAO,CAAC,WAAR,GAAsB,OAAtB,CAA8B,YAAY,CAAC,WAAb,EAA9B,MAA8D,CAAlE,EAAqE;AACjE,QAAA,aAAa,GAAG,OAAO,CAAC,KAAR,CAAc,YAAY,CAAC,MAA3B,CAAhB;AACH,OAFD,MAEO;AACH,QAAA,aAAa,GAAG,OAAhB;AACH;;AAED,UAAI,CAAC,mBAAD,IAAwB,CAAC,KAAK,CAAC,QAAN,CAAe,MAA5C,EAAoD;AAChD,QAAA,aAAa,GAAG,aAAa,CAAC,OAAd,CAAsB,OAAtB,EAA+B,GAA/B,CAAhB;AACH;;AAED,kBAAwB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAR,CAAgB,YAAhB,EAA8B,EAA9B,CAAD,CAAV,EAA+C,KAAK,CAAC,MAAN,CAAc,WAA7D,EAA0E,OAAO,CAAC,WAAlF,CAA5B;AAAA,UAAQ,WAAR,SAAQ,WAAR;;AAEA,MAAA,aAAa,GAAG,OAAO,CAAC,aAAD,CAAP,IAA0B,WAAW,SAAO,WAAP,GAAuB,EAA5D,CAAhB;;AAEA,UAAI,CAAC,mBAAD,IAAwB,CAAC,MAAzB,IAAmC,aAAa,KAAK,GAArD,IAA4D,CAAC,MAAM,IAAN,CAAW,YAAX,CAAjE,EAA2F;AACvF,QAAA,aAAa,GAAG,EAAhB;AACH;;AAED,MAAA,YAAY,CAAC,QAAb,CAAsB,IAAtB,CAA2B,KAA3B;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,OAAnB,CAA2B,UAAC,KAAD;AAAA,eAAY,YAAY,CAAC,MAAb,CAAoB,KAApB,IAA6B,KAAM,CAAC,KAAD,CAA/C;AAAA,OAA3B;;AAEA,UAAI,CAAC,MAAD,IAAW,CAAC,aAAa,CAAC,MAA9B,EAAsC;AAClC;AACA;AAAA,aAAO;AAAP;AACH;;AAED,UAAI,CAAC,MAAD,IAAW,eAAe,KAAK,QAA/B,IAA2C,aAAa,CAAC,OAAd,CAAsB,GAAtB,MAA+B,CAA9E,EAAiF;AAC7E;AACA,YAAM,oBAAoB,GAAG,KAAK,CAAC,aAAa,CAAC,KAAd,CAAoB,CAApB,CAAD,EAAyB,OAAO,CAAC,WAAjC,CAAlC;AAEA,QAAA,MAAM,CAAC,IAAP,CAAY,oBAAZ,EAAkC,OAAlC,CAA0C,UAAC,IAAD;AAAA,iBAAW,YAAY,CAAC,MAAb,CAAoB,IAApB,IAA4B,oBAAoB,CAAC,IAAD,CAA3D;AAAA,SAA1C;AAEA;AAAA,aAAO;AAAP;AACH,OA9CM;;;AAiDP,UAAM,QAAQ,GAAG,KAAK,CAAC,sBAAN,EAAjB,CAjDO;;AAmDP,UAAI,CAAC,QAAQ,CAAC,MAAd,EAAsB;AAClB;AAAA,aAAO;AAAP;AACH,OArDM;;;AAwDP;AAAA,WAAO,aAAa,CAAC,QAAD,EAAW,aAAX,EAA0B,YAA1B,EAAwC,OAAxC,EAAiD,YAAjD;AAApB;AACH;AA5FiB;;AAKtB,uDAAoB,KAApB,wCAA2B;AAAA;;AAAA;AAwF1B;;AAED,SAAO,IAAP;AACH,CAtGD;;ACNc,SAAU,YAAV,CAAuB,QAAvB,EAA4C;AACtD,MAAM,gBAAgB,GAAG,QAAQ,CAAC,KAAT,CAAe,CAAf,CAAzB;AAEA,SAAO,QAAQ,CAAC,IAAT,CAAc,aAAa,CAAC,gBAAD,CAA3B,CAAP;AACH;;AAED,IAAM,aAAa,GACf,SADE,aACF,CAAC,gBAAD;AAAA,SACA,UAAC,IAAD,EAAkB,KAAlB,EAA8C;AAAA;;AAC1C,QAAM,QAAQ,GAAG,IAAI,CAAC,IAAL,CACZ,OADY,CACJ,QADI,EACM,EADN,EAEZ,KAFY,CAEN,GAFM,EAED,CAFC,EAGZ,OAHY,CAGJ,SAHI,EAGO,IAHP,CAAjB;AAKA,QAAM,SAAS,GAAG,KAAK,CAAC,IAAN,CACb,OADa,CACL,QADK,EACK,EADL,EAEb,KAFa,CAEP,GAFO,EAEF,CAFE,EAGb,OAHa,CAGL,SAHK,EAGM,IAHN,CAAlB,CAN0C;;AAY1C,QAAI,QAAQ,KAAK,GAAjB,EAAsB;AAClB,aAAO,CAAP;AACH;;AAED,QAAI,SAAS,KAAK,GAAlB,EAAuB;AACnB,aAAO,CAAC,CAAR;AACH,KAlByC;;;AAqB1C,wBAAI,IAAI,CAAC,MAAT,aAAI,aAAa,YAAjB,EAA+B;AAC3B,aAAO,CAAP;AACH;;AAED,yBAAI,KAAK,CAAC,MAAV,aAAI,cAAc,YAAlB,EAAgC;AAC5B,aAAO,CAAC,CAAR;AACH,KA3ByC;;;AA8B1C,QAAM,YAAY,GAAG,CAAC,QAAQ,CAAC,KAAT,CAAe,KAAf,KAAyB,EAA1B,EAA8B,MAAnD;AACA,QAAM,aAAa,GAAG,CAAC,SAAS,CAAC,KAAV,CAAgB,KAAhB,KAA0B,EAA3B,EAA+B,MAArD;;AACA,QAAI,YAAY,GAAG,aAAnB,EAAkC;AAC9B,aAAO,CAAP;AACH;;AAED,QAAI,YAAY,GAAG,aAAnB,EAAkC;AAC9B,aAAO,CAAC,CAAR;AACH,KAtCyC;;;AAyC1C,QAAM,eAAe,6CAAG,IAAI,CAAC,MAAR,qBAAG,cAAa,SAAb,CAAuB,MAA1B,oCAAoC,CAAzD;AACA,QAAM,gBAAgB,8CAAG,KAAK,CAAC,MAAT,qBAAG,eAAc,SAAd,CAAwB,MAA3B,oCAAqC,CAA3D;;AACA,QAAI,eAAe,GAAG,gBAAtB,EAAwC;AACpC,aAAO,CAAC,CAAR;AACH;;AAED,QAAI,eAAe,GAAG,gBAAtB,EAAwC;AACpC,aAAO,CAAP;AACH,KAjDyC;;;AAoD1C,QAAM,eAAe,GAAG,CAAC,QAAQ,CAAC,KAAT,CAAe,GAAf,EAAoB,KAApB,CAA0B,CAAC,CAA3B,EAA8B,CAA9B,KAAoC,EAArC,EAAyC,MAAjE;AACA,QAAM,gBAAgB,GAAG,CAAC,SAAS,CAAC,KAAV,CAAgB,GAAhB,EAAqB,KAArB,CAA2B,CAAC,CAA5B,EAA+B,CAA/B,KAAqC,EAAtC,EAA0C,MAAnE;;AACA,QAAI,eAAe,GAAG,gBAAtB,EAAwC;AACpC,aAAO,CAAP;AACH;;AAED,QAAI,eAAe,GAAG,gBAAtB,EAAwC;AACpC,aAAO,CAAC,CAAR;AACH,KA5DyC;AA+D1C;;;AACA,WAAO,gBAAgB,CAAC,OAAjB,CAAyB,IAAzB,IAAiC,gBAAgB,CAAC,OAAjB,CAAyB,KAAzB,CAAxC;AACH,GAlED;AAAA,CADJ;;ICoDa,SAAb;AAQI,qBAAY,IAAZ,EAA+B,IAA/B,EAAkD,WAAlD,EAA6E,OAA7E,EAA2G;AAAA,QAA/F,IAA+F;AAA/F,MAAA,IAA+F,GAAhF,EAAgF;AAAA;;AAAA,QAA5E,IAA4E;AAA5E,MAAA,IAA4E,GAA7D,EAA6D;AAAA;;AAAA,QAAzD,WAAyD;AAAzD,MAAA,WAAyD,GAAlC,EAAkC;AAAA;;AAAA,QAA9B,OAA8B;AAA9B,MAAA,OAA8B,GAAF,EAAE;AAAA;;AAAA,SAPpG,IAOoG;AAAA,SANpG,QAMoG;AAAA,SALpG,IAKoG;AAAA,SAJpG,MAIoG;AAAA,SAHpG,QAGoG;AAAA,SAFpG,MAEoG;AACvG,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,QAAL,GAAgB,KAAK,IAAL,CAAU,IAAV,CAAhB;AACA,SAAK,IAAL,GAAY,KAAK,QAAL,GAAgB,IAAI,CAAC,KAAL,CAAW,CAAX,CAAhB,GAAgC,IAA5C;AAEA,SAAK,MAAL,GAAc,KAAK,IAAL,GAAY,IAAI,IAAJ,CAAS,KAAK,IAAd,CAAZ,GAAkC,IAAhD;AACA,SAAK,QAAL,GAAgB,EAAhB;AACA,SAAK,MAAL,GAAc,OAAO,CAAC,MAAtB;AAEA,SAAK,YAAL;AAEA,SAAK,GAAL,CAAS,WAAT,EAAsB,OAAO,CAAC,KAA9B,EAAqC,OAAO,CAAC,SAAR,GAAoB,KAApB,GAA4B,OAAO,CAAC,IAAR,KAAiB,KAAlF;;AAEA,QAAI,OAAO,CAAC,SAAZ,EAAuB;AACnB,WAAK,eAAL;AACH;;AAED,WAAO,IAAP;AACH;;AA1BL;;AAAA,SA4BW,iBA5BX,GA4BW,2BAAkB,QAAlB,EAA4C;AAAA,QAA1B,QAA0B;AAA1B,MAAA,QAA0B,GAAF,EAAE;AAAA;;AAC/C,WAAO,KAAK,MAAL,IAAe,KAAK,MAAL,CAAY,MAA3B,GAAoC,KAAK,MAAL,CAAY,iBAAZ,CAA8B,QAAQ,CAAC,MAAT,CAAgB,KAAK,MAArB,CAA9B,CAApC,GAAkG,QAAQ,CAAC,OAAT,EAAzG;AACH,GA9BL;;AAAA,SAgCW,SAhCX,GAgCW,mBAAU,MAAV,EAA2B;AAC9B,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,YAAL;AACH,GAnCL;;AAAA,SAqCW,OArCX,GAqCW,iBAAQ,IAAR,EAAyB;AAAA,QAAjB,IAAiB;AAAjB,MAAA,IAAiB,GAAF,EAAE;AAAA;;AAC5B,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,MAAL,GAAc,IAAI,GAAG,IAAI,IAAJ,CAAS,IAAT,CAAH,GAAoB,IAAtC;AACH,GAxCL;;AAAA,SA0CW,GA1CX,GA0CW,aAAI,KAAJ,EAA4B,EAA5B,EAA2C,IAA3C,EAA+D;AAAA;;AAAA,QAApB,IAAoB;AAApB,MAAA,IAAoB,GAAJ,IAAI;AAAA;;AAClE,QAAI,KAAK,KAAK,SAAV,IAAuB,KAAK,KAAK,IAArC,EAA2C;AACvC,aAAO,IAAP;AACH;;AAED,QAAI,KAAK,YAAY,KAArB,EAA4B;AACxB,MAAA,KAAK,CAAC,OAAN,CAAc,UAAC,CAAD;AAAA,eAAO,KAAI,CAAC,GAAL,CAAS,CAAT,EAAY,EAAZ,EAAgB,IAAhB,CAAP;AAAA,OAAd;AACA,aAAO,IAAP;AACH;;AAED,QAAI,EAAE,KAAK,YAAY,SAAnB,KAAiC,EAAE,KAAK,YAAY,MAAnB,CAArC,EAAiE;AAC7D,YAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH,KAFD,MAEO,IAAI,KAAK,YAAY,SAArB,EAAgC;AACnC,MAAA,KAAK,CAAC,SAAN,CAAgB,IAAhB;AACA,WAAK,YAAL,CAAkB,KAAlB,EAAyB,IAAzB;AACH,KAHM,MAGA;AACH,UAAI,CAAC,KAAK,CAAC,IAAP,IAAe,CAAC,KAAK,CAAC,IAA1B,EAAgC;AAC5B,cAAM,IAAI,KAAJ,CAAU,mEAAV,CAAN;AACH;;AAED,UAAM,SAAS,GAAG,IAAI,SAAJ,CAAc,KAAK,CAAC,IAApB,EAA0B,KAAK,CAAC,IAAhC,EAAsC,KAAK,CAAC,QAA5C,EAAsD;AACpE,QAAA,SAAS,EAAE,KADyD;AAEpE,QAAA,KAAK,EAAE,EAF6D;AAGpE,QAAA,MAAM,EAAE,IAH4D;AAIpE,QAAA,IAAI,EAAJ;AAJoE,OAAtD,CAAlB;AAOA,UAAM,QAAQ,GAAG,SAAS,CACrB,iBADY,CACM,CAAC,SAAD,CADN,EAEZ,GAFY,CAER,UAAC,CAAD;AAAA,eAAO,CAAC,CAAC,IAAT;AAAA,OAFQ,EAGZ,IAHY,CAGP,GAHO,CAAjB;;AAKA,UAAI,EAAJ,EAAQ;AACJ,QAAA,EAAE,cACK,KADL;AAEE,UAAA,IAAI,EAAE;AAFR,WAAF;AAIH;;AAED,WAAK,YAAL,CAAkB,SAAlB,EAA6B,IAA7B;AACH;;AAED,WAAO,IAAP;AACH,GArFL;;AAAA,SAuFW,OAvFX,GAuFW,iBAAQ,IAAR,EAAsB,IAAtB,EAAkC;AACrC,SAAK,GAAL,CAAS,IAAI,SAAJ,CAAc,IAAd,EAAoB,IAApB,CAAT;AACA,WAAO,IAAP;AACH,GA1FL;;AAAA,SA4FW,OA5FX,GA4FW,iBAAQ,SAAR,EAAyB;AAC5B,QAAM,cAAc,GAAG,KAAK,iBAAL,CAAuB,SAAvB,CAAvB;AAEA,WAAO,cAAc,GAAG,mBAAmB,CAAC,cAAD,CAAtB,GAAyC,IAA9D;AACH,GAhGL;;AAAA,SAkGW,sBAlGX,GAkGW,kCAAsB;AACzB,WAAO,KAAK,QAAL,CAAc,MAAd,CAAqB,UAAC,KAAD;AAAA,aAAW,CAAC,KAAK,CAAC,QAAlB;AAAA,KAArB,CAAP;AACH,GApGL;;AAAA,SAsGW,YAtGX,GAsGW,0BAAY;AACf,QAAI,KAAK,QAAL,CAAc,MAAlB,EAA0B;AACtB,MAAAC,YAAY,CAAC,KAAK,QAAN,CAAZ;AACH;AACJ,GA1GL;;AAAA,SA4GW,eA5GX,GA4GW,2BAAe;AAClB,SAAK,YAAL;AACA,SAAK,QAAL,CAAc,OAAd,CAAsB,UAAC,KAAD;AAAA,aAAW,KAAK,CAAC,eAAN,EAAX;AAAA,KAAtB;AACH,GA/GL;;AAAA,SAiHW,SAjHX,GAiHW,mBAAU,SAAV,EAA6B,MAA7B,EAA+D,OAA/D,EAAyF;AAAA,QAA5D,MAA4D;AAA5D,MAAA,MAA4D,GAA9B,EAA8B;AAAA;;AAAA,QAA1B,OAA0B;AAA1B,MAAA,OAA0B,GAAF,EAAE;AAAA;;AAC5F,QAAM,QAAQ,GAAG,KAAK,iBAAL,CAAuB,SAAvB,CAAjB;;AAEA,QAAI,CAAC,QAAL,EAAe;AACX,YAAM,IAAI,KAAJ,CAAU,sDAAV,CAAN;AACH;;AAED,WAAO,qBAAqB,CAAC,QAAD,EAAW,MAAX,EAAmB,OAAnB,CAA5B;AACH,GAzHL;;AAAA,SA2HW,UA3HX,GA2HW,oBAAW,IAAX,EAAyB,MAAzB,EAAyD;AAAA,QAAhC,MAAgC;AAAhC,MAAA,MAAgC,GAAF,EAAE;AAAA;;AAC5D,QAAM,QAAQ,GAAG,KAAK,iBAAL,CAAuB,IAAvB,CAAjB;;AAEA,QAAI,CAAC,QAAD,IAAa,CAAC,QAAQ,CAAC,MAA3B,EAAmC;AAC/B,aAAO,IAAP;AACH;;AAED,WAAO;AACH,MAAA,IAAI,EAAJ,IADG;AAEH,MAAA,MAAM,EAAN,MAFG;AAGH,MAAA,IAAI,EAAE,mBAAmB,CAAC,QAAD;AAHtB,KAAP;AAKH,GAvIL;;AAAA,SAyIW,SAzIX,GAyIW,mBAAU,IAAV,EAAwB,OAAxB,EAAkD;AAAA,QAA1B,OAA0B;AAA1B,MAAA,OAA0B,GAAF,EAAE;AAAA;;AACrD,QAAI,IAAI,KAAK,EAAT,IAAe,CAAC,OAAO,CAAC,mBAA5B,EAAiD;AAC7C,MAAA,IAAI,GAAG,GAAP;AACH;;AAED,QAAM,KAAK,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,OAAnC,CAAd;;AAEA,QAAI,CAAC,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AAED,QAAM,eAAe,GAAG,KAAK,CAAC,QAA9B;;AAEA,QAAI,eAAe,CAAC,CAAD,CAAf,CAAmB,QAAvB,EAAiC;AAC7B,UAAM,kBAAkB,GAAG,eAAe,CAAC,CAAD,CAAf,CAAmB,iBAAnB,EAA3B;AAEA,MAAA,eAAe,CAAC,OAAhB;AACA,MAAA,eAAe,CAAC,IAAhB,OAAA,eAAe,EAAS,kBAAT,CAAf;AACA,MAAA,eAAe,CAAC,OAAhB;AACH;;AAED,QAAM,WAAW,GAAG,eAAe,CAAC,eAAe,CAAC,MAAhB,GAAyB,CAA1B,CAAnC;AACA,QAAM,qBAAqB,GAAG,WAAW,CAAC,cAAZ,EAA9B;;AAEA,QAAI,qBAAJ,EAA2B;AACvB,MAAA,eAAe,CAAC,IAAhB,CAAqB,qBAArB;AACH;;AAED,WAAO,mBAAmB,CAAC,KAAD,CAA1B;AACH,GAtKL;;AAAA,SAwKY,YAxKZ,GAwKY,sBAAa,KAAb,EAA+B,IAA/B,EAAmD;AAAA,QAApB,IAAoB;AAApB,MAAA,IAAoB,GAAJ,IAAI;AAAA;;AACvD,QAAM,KAAK,GAAG,KAAK,CAAC,IAAN,CAAW,KAAX,CAAiB,GAAjB,CAAd;;AAEA,QAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB;AACA,UAAI,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,KAAD;AAAA,eAAW,KAAK,CAAC,IAAjB;AAAA,OAAlB,EAAyC,OAAzC,CAAiD,KAAK,CAAC,IAAvD,MAAiE,CAAC,CAAtE,EAAyE;AACrE,cAAM,IAAI,KAAJ,cAAoB,KAAK,CAAC,IAA1B,yCAAN;AACH,OAJmB;;;AAOpB,UAAI,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAC,KAAD;AAAA,eAAW,KAAK,CAAC,IAAjB;AAAA,OAAlB,EAAyC,OAAzC,CAAiD,KAAK,CAAC,IAAvD,MAAiE,CAAC,CAAtE,EAAyE;AACrE,cAAM,IAAI,KAAJ,aAAmB,KAAK,CAAC,IAAzB,yCAAN;AACH;;AAED,WAAK,QAAL,CAAc,IAAd,CAAmB,KAAnB;;AAEA,UAAI,IAAJ,EAAU;AACN,aAAK,YAAL;AACH;AACJ,KAhBD,MAgBO;AACH;AACA,UAAM,QAAQ,GAAG,KAAK,iBAAL,CAAuB,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,EAAmB,IAAnB,CAAwB,GAAxB,CAAvB,CAAjB;;AACA,UAAI,QAAJ,EAAc;AACV,QAAA,KAAK,CAAC,IAAN,GAAa,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAlB;AACA,QAAA,QAAQ,CAAC,QAAQ,CAAC,MAAT,GAAkB,CAAnB,CAAR,CAA8B,GAA9B,CAAkC,KAAlC;AACH,OAHD,MAGO;AACH,cAAM,IAAI,KAAJ,iCAAwC,KAAK,CAAC,IAA9C,2BAAN;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GAvML;;AAAA,SAyMY,YAzMZ,GAyMY,wBAAY;AAChB,QAAI,KAAK,QAAL,IAAiB,KAAK,gBAAL,EAArB,EAA8C;AAC1C,YAAM,IAAI,KAAJ,CAAU,wFAAV,CAAN;AACH;AACJ,GA7ML;;AAAA,SA+MY,gBA/MZ,GA+MY,4BAAgB;AACpB,QAAI,KAAK,MAAL,IAAe,KAAK,MAAL,CAAY,MAA/B,EAAuC;AACnC,UAAM,MAAM,GAAG,KAAK,MAAL,CAAY,MAA3B;AACA,UAAM,SAAS,GAAG,MAAM,CAAC,YAAP,IAAuB,MAAM,CAAC,YAA9B,IAA8C,MAAM,CAAC,eAArD,IAAwE,MAAM,CAAC,cAAjG;AAEA,aAAO,SAAS,IAAI,KAAK,MAAL,CAAY,gBAAZ,EAApB;AACH;;AAED,WAAO,KAAP;AACH,GAxNL;;AAAA,SA0NY,oBA1NZ,GA0NY,gCAAoB;AACxB,WAAO,KAAK,QAAL,CAAc,MAAd,CACH,UAAC,gBAAD,EAAmB,KAAnB;AAAA,aAA6B,gBAAgB,CAAC,MAAjB,CAAwB,KAAK,CAAC,QAAN,GAAiB,KAAjB,GAAyB,EAAjD,EAAqD,MAArD,CAA4D,KAAK,CAAC,oBAAN,EAA5D,CAA7B;AAAA,KADG,EAEH,EAFG,CAAP;AAIH,GA/NL;;AAAA,SAiOY,cAjOZ,GAiOY,0BAAc;AAClB,QAAM,aAAa,GAAG,KAAK,sBAAL,GAA8B,MAA9B,CAAqC,UAAC,KAAD;AAAA,aAAW,KAAK,CAAC,MAAN,IAAgB,YAAY,IAAZ,CAAiB,KAAK,CAAC,MAAN,CAAa,IAA9B,CAA3B;AAAA,KAArC,CAAtB;AAEA,WAAO,aAAa,CAAC,CAAD,CAApB;AACH,GArOL;;AAAA,SAuOY,iBAvOZ,GAuOY,2BAAkB,SAAlB,EAAmC;AACvC,QAAM,iBAAiB,GAAG,SAApB,iBAAoB,CAAC,IAAD,EAAe,MAAf,EAAsC;AAC5D,UAAM,cAAc,GAAG,MAAM,CAAC,MAAP,CAAc,UAAC,CAAD;AAAA,eAAO,CAAC,CAAC,IAAF,KAAW,IAAlB;AAAA,OAAd,CAAvB;AACA,aAAO,cAAc,CAAC,MAAf,GAAwB,cAAc,CAAC,CAAD,CAAtC,GAA4C,SAAnD;AACH,KAHD;;AAKA,QAAM,QAAQ,GAAgB,EAA9B;AACA,QAAI,MAAM,GAAG,KAAK,MAAL,GAAc,CAAC,IAAD,CAAd,GAAuB,KAAK,QAAzC;AACA,QAAM,KAAK,GAAG,CAAC,KAAK,MAAL,GAAc,CAAC,EAAD,CAAd,GAAqB,EAAtB,EAA0B,MAA1B,CAAiC,SAAS,CAAC,KAAV,CAAgB,GAAhB,CAAjC,CAAd;AAEA,QAAM,OAAO,GAAG,KAAK,CAAC,KAAN,CAAY,UAAC,IAAD,EAAS;AACjC,UAAM,OAAO,GAAG,iBAAiB,CAAC,IAAD,EAAO,MAAP,CAAjC;;AACA,UAAI,OAAJ,EAAa;AACT,QAAA,MAAM,GAAG,OAAO,CAAC,QAAjB;AACA,QAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;AACA,eAAO,IAAP;AACH;;AAED,aAAO,KAAP;AACH,KATe,CAAhB;AAWA,WAAO,OAAO,GAAG,QAAH,GAAc,IAA5B;AACH,GA7PL;;AAAA,SA+PY,uBA/PZ,GA+PY,iCAAwB,IAAxB,EAAsC,OAAtC,EAA2D;AAC/D,QAAM,aAAa,GAAG,KAAK,MAAL,GAAc,CAAC,IAAD,CAAd,GAAuB,KAAK,QAAlD;AACA,QAAM,aAAa,GAAG,aAAa,CAAC,MAAd,CAAkC,UAAC,KAAD,EAAQ,IAAR;AAAA,aAAiB,KAAK,CAAC,MAAN,CAAa,IAAb,EAAmB,IAAI,CAAC,oBAAL,EAAnB,CAAjB;AAAA,KAAlC,EAAoG,EAApG,CAAtB;AAEA,QAAM,YAAY,GAAG;AACjB,MAAA,QAAQ,EAAE,EADO;AAEjB,MAAA,MAAM,EAAE;AAFS,KAArB;AAKA,QAAM,UAAU,GAAG,aAAa,CAAC,aAAD,EAAgB,IAAhB,EAAsB,YAAtB,EAAoC,OAApC,CAAhC;;AAEA,QAAI,UAAU,IAAI,UAAU,CAAC,QAAX,CAAoB,MAApB,KAA+B,CAA7C,IAAkD,UAAU,CAAC,QAAX,CAAoB,CAApB,EAAuB,IAAvB,KAAgC,EAAtF,EAA0F;AACtF,aAAO,IAAP;AACH;;AAED,WAAO,UAAP;AACH,GA/QL;;AAAA;AAAA;;;;;;;;;"}